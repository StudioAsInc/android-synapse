package com.synapse.social.studioasinc

import android.content.Context
import android.text.TextUtils
import android.util.Log
import android.widget.EditText
import android.widget.LinearLayout
import android.widget.Toast
import androidx.recyclerview.widget.RecyclerView
import android.view.View
import com.synapse.social.studioasinc.backend.SupabaseAuthenticationService
import com.synapse.social.studioasinc.backend.SupabaseChatService
import com.synapse.social.studioasinc.backend.SupabaseDatabaseService
import com.synapse.social.studioasinc.util.SupabaseChatUtils
import com.synapse.social.studioasinc.model.ChatMessage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.ArrayList
import java.util.HashMap
import android.widget.RelativeLayout

class MessageSendingHandler(
    private val context: Context,
    private val authService: SupabaseAuthenticationService,
    private val databaseService: SupabaseDatabaseService,
    private val chatMessagesList: ArrayList<HashMap<String, Any>>,
    private val attactmentmap: ArrayList<HashMap<String, Any>>,
    private val chatAdapter: ChatAdapter,
    private val chatMessagesListRecycler: RecyclerView,
    private val rv_attacmentList: RecyclerView,
    private val attachmentLayoutListHolder: RelativeLayout,
    private val messageKeys: MutableSet<String>,
    private val recipientUid: String,
    private var firstUserName: String,
    private val isGroup: Boolean
) {

    private val chatService = SupabaseChatService()

    fun setFirstUserName(name: String) {
        this.firstUserName = name
    }

    fun sendButtonAction(messageEt: EditText, replyMessageID: String, mMessageReplyLayout: LinearLayout) {
        val messageText = messageEt.text.toString().trim()
        val currentUser = authService.getCurrentUser() ?: return
        val senderUid = currentUser.id

        proceedWithMessageSending(messageText, senderUid, recipientUid, replyMessageID, messageEt, mMessageReplyLayout)
    }

    private fun proceedWithMessageSending(
        messageText: String,
        senderUid: String,
        recipientUid: String,
        replyMessageID: String,
        messageEt: EditText,
        mMessageReplyLayout: LinearLayout
    ) {
        // Set user activity to idle
        PresenceManager.setActivity(senderUid, "Idle")

        if (attactmentmap.isEmpty() && messageText.isEmpty()) {
            Log.w("MessageSendingHandler", "No message text and no attachments - nothing to send")
            return
        }

        val uniqueMessageKey = SupabaseChatUtils.generateMessageId()
        val lastMessageForInbox: String

        CoroutineScope(Dispatchers.IO).launch {
            try {
                val chatId = SupabaseChatUtils.getChatId(senderUid, recipientUid)
                
                if (attactmentmap.isNotEmpty()) {
                    // Handle attachments
                    val successfulAttachments = ArrayList<HashMap<String, Any>>()
                    var allUploadsSuccessful = true
                    
                    for (item in attactmentmap) {
                        if ("success" == item["uploadState"]) {
                            val attachmentData = HashMap<String, Any>()
                            attachmentData["url"] = item["cloudinaryUrl"] as Any
                            attachmentData["publicId"] = item["publicId"] as Any
                            attachmentData["width"] = item["width"] as Any
                            attachmentData["height"] = item["height"] as Any
                            successfulAttachments.add(attachmentData)
                        } else {
                            allUploadsSuccessful = false
                        }
                    }

                    if (!allUploadsSuccessful) {
                        withContext(Dispatchers.Main) {
                            Toast.makeText(context, "Waiting for uploads to complete...", Toast.LENGTH_SHORT).show()
                        }
                        return@launch
                    }

                    lastMessageForInbox = if (messageText.isEmpty()) "${successfulAttachments.size} attachment(s)" else messageText
                    
                    // Send attachment message
                    val result = chatService.sendMessage(chatId, senderUid, messageText, "attachment")
                    
                    if (result.isFailure) {
                        withContext(Dispatchers.Main) {
                            Toast.makeText(context, "Failed to send attachment", Toast.LENGTH_SHORT).show()
                        }
                        return@launch
                    }
                } else {
                    // Text-only message
                    lastMessageForInbox = messageText
                    
                    if (!SupabaseChatUtils.isValidMessage(messageText)) {
                        withContext(Dispatchers.Main) {
                            Toast.makeText(context, "Invalid message", Toast.LENGTH_SHORT).show()
                        }
                        return@launch
                    }
                    
                    val sanitizedMessage = SupabaseChatUtils.sanitizeMessage(messageText)
                    val result = chatService.sendMessage(chatId, senderUid, sanitizedMessage, "text")
                    
                    if (result.isFailure) {
                        withContext(Dispatchers.Main) {
                            Toast.makeText(context, "Failed to send message", Toast.LENGTH_SHORT).show()
                        }
                        return@launch
                    }
                }

                // Update UI on main thread
                withContext(Dispatchers.Main) {
                    val localMessage = HashMap<String, Any>()
                    localMessage["id"] = uniqueMessageKey
                    localMessage["sender_id"] = senderUid
                    localMessage["message"] = messageText
                    localMessage["timestamp"] = System.currentTimeMillis().toString()
                    localMessage["isLocalMessage"] = true
                    
                    messageKeys.add(uniqueMessageKey)
                    chatMessagesList.add(localMessage)

                    val newPosition = chatMessagesList.size - 1
                    chatAdapter.notifyItemInserted(newPosition)
                    if (newPosition > 0) chatAdapter.notifyItemChanged(newPosition - 1)

                    chatMessagesListRecycler.post { 
                        chatMessagesListRecycler.smoothScrollToPosition(chatMessagesList.size - 1) 
                    }

                    messageEt.setText("")
                    mMessageReplyLayout.visibility = View.GONE
                    
                    if (attactmentmap.isNotEmpty()) {
                        resetAttachmentState()
                    }
                    
                    Toast.makeText(context, "Message sent", Toast.LENGTH_SHORT).show()
                }

                // Send notification (simplified)
                sendNotification(senderUid, recipientUid, lastMessageForInbox, chatId)

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(context, "Failed to send message: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    fun sendVoiceMessage(audioUrl: String, duration: Long, replyMessageID: String, mMessageReplyLayout: LinearLayout) {
        val currentUser = authService.getCurrentUser() ?: return
        val senderUid = currentUser.id
        val uniqueMessageKey = SupabaseChatUtils.generateMessageId()

        CoroutineScope(Dispatchers.IO).launch {
            try {
                val chatId = SupabaseChatUtils.getChatId(senderUid, recipientUid)
                val result = chatService.sendMessage(chatId, senderUid, "Voice Message", "voice")
                
                if (result.isSuccess) {
                    withContext(Dispatchers.Main) {
                        val localMessage = HashMap<String, Any>()
                        localMessage["id"] = uniqueMessageKey
                        localMessage["sender_id"] = senderUid
                        localMessage["message"] = "Voice Message"
                        localMessage["message_type"] = "voice"
                        localMessage["audio_url"] = audioUrl
                        localMessage["audio_duration"] = duration
                        localMessage["timestamp"] = System.currentTimeMillis().toString()
                        localMessage["isLocalMessage"] = true
                        
                        messageKeys.add(uniqueMessageKey)
                        chatMessagesList.add(localMessage)
                        chatAdapter.notifyItemInserted(chatMessagesList.size - 1)
                        chatMessagesListRecycler.post { 
                            chatMessagesListRecycler.smoothScrollToPosition(chatMessagesList.size - 1) 
                        }

                        mMessageReplyLayout.visibility = View.GONE
                        Toast.makeText(context, "Voice message sent", Toast.LENGTH_SHORT).show()
                    }
                } else {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(context, "Failed to send voice message", Toast.LENGTH_SHORT).show()
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(context, "Failed to send voice message: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun resetAttachmentState() {
        attachmentLayoutListHolder.visibility = View.GONE
        val oldSize = attactmentmap.size
        if (oldSize > 0) {
            attactmentmap.clear()
            rv_attacmentList.adapter?.notifyItemRangeRemoved(0, oldSize)
        }
    }
    
    private suspend fun sendNotification(senderUid: String, recipientUid: String, message: String, chatId: String) {
        // Simplified notification - you can enhance this with OneSignal integration
        try {
            val senderDisplayName = if (TextUtils.isEmpty(firstUserName)) "Someone" else firstUserName
            val notificationMessage = "$senderDisplayName: $message"
            
            // Get recipient's notification ID from database
            val recipientData = databaseService.selectById("users", recipientUid, "one_signal_player_id").getOrNull()
            val playerId = recipientData?.get("one_signal_player_id") as? String ?: "missing_id"
            
            // Send notification using NotificationHelper (if available)
            // NotificationHelper.sendMessageAndNotifyIfNeeded(senderUid, recipientUid, playerId, notificationMessage, chatId)
            
        } catch (e: Exception) {
            Log.e("MessageSendingHandler", "Failed to send notification", e)
        }
    }
}